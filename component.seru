from "github.com/Serulian/corelib:master" import Map, List
from "github.com/Serulian/corelib:master" import SimpleError
from eventmanager import EventManager
from types import VirtualNode, FunctionReference

/**
 * Context defines an interface provided to components via their Reduce methods that
 * contains all context-sensitive information needed for the reduction down to VirtualDOM.
 */
interface Context {
	/**
	 * Get looks up the context field with the given name and type. Returns it or null if
	 * the name was not found. Should reject if the cast to type T fails.
	 */
	function<T?> Get<T>(name string)

	/**
	 * EventManager returns the Event Manager for registering callbacks.
	 */
	property<EventManager> EventManager { get }
}

/**
 * EmptyContext defines an implementation of Context that simply contains an EventManager
 * and no other contextual data.
 */
class EmptyContext {
	var<EventManager> em

	constructor WithEventManager(em EventManager) { return EmptyContext{em: em} }

	property<EventManager> EventManager {
		get  { return this.em }
	}

	function<T?> Get<T>(name string) { return null }
}

/**
 * Reducible marks an instance as being reducible into a VirtualNode or component.
 */
interface Reducible {
	/**
	 * Reduce returns the reduced version of the component. This is typically a VirtualNode
	 * tree, but can also be another Reducible.
	 */
	function<any> Reduce(context Context)
}

/**
 * Reduce builds a new virtual DOM node for the given reducible component.
 */
function<VirtualNode> Reduce(component any, context Context) {
	var<any> current = component

	for true {
		if current is null {
			// Render as an empty text node.
			return VirtualNode{Text: ''}
		}

		match current as typedValue {
			case VirtualNode:
				return typedValue

			case Reducible:
				current = typedValue.Reduce(context)

			default:
				reject SimpleError.WithMessage('Unsupported value under Reduce. Did you forget to add a Reduce method?')
		}
	}

	return VirtualNode{Text: ''}
}

/**
 * renderableVirtualNode defines a component which represents a VirtualNode. We return this
 * from SML (instead of an actual VirtualNode) because it allows for lazy evaluation of its
 * children.
 */
class renderableVirtualNode {
	var<string> tagName
	var<[]{any}> props
	var<any*> children

	function<any> Reduce(context Context) {
		var attributes = Map<string, string>.Empty()
		var eventHandlers = Map<string, FunctionReference>.Empty()
		var<string?> key = null
		var<FunctionReference?> nodeInsertedHandler = null

		props := this.props
		children := this.children

		// Convert the props into attributes, the key, and callbacks.
		if !props.IsEmpty {
			if props["Key"] is not null {
				key = props["Key"].(string)
			}

			for name in props.Keys {
				if name == "ondomnodeinserted" {
					fn := props[name].(function<void>(any))
					nodeInsertedHandler = context.EventManager.RegisterFunction(fn)
				} else if name.HasPrefix("on") {
					fn := props[name].(function<void>(any))
					eventHandlers[name[2:]] = context.EventManager.RegisterFunction(fn)
				} else if name != "Key" {
					if name == "className" {
						attributes['class'] = props[name].(string)
					} else {
						attributes[name] = props[name].(string)
					}
				}
			}
		}

		// Reduce the children into their VirtualNode representations.
		var childList = List<VirtualNode>.Empty()
		for child in children {
			// We skip null children, as they are the result of decorators deciding
			// not to add the child.
			if child is null {
				continue
			}

			match child as typedChild {
				case string:
					childList.Add(VirtualNode{Text: typedChild})

				case VirtualNode:
					childList.Add(typedChild)

				case Reducible:
					childList.Add(Reduce(typedChild, context))

				default:
					reject SimpleError.WithMessage('Unsupported instance under VirtualNode. Did you forget to add a Reduce() method to a class?')
			}
		}

		return VirtualNode{
			Key: key,
			TagName: this.tagName,
			EventHandlers: eventHandlers.Mapping(),
			Attributes: attributes.Mapping(),
			Children: childList[0:],
			DOMNodeInserted: nodeInsertedHandler,
		}
	}
}
